<template>
    <div class="memory-management-container">
      <h1 class="main-title">Memory Management</h1>
      <p class="intro">
        Memory management is a crucial function of an operating system that involves managing computer memory, allocating space for programs, and ensuring efficient memory usage.
      </p>
  
      <h2 class="sub-title">Memory Hierarchy Design and its Characteristics</h2>
      <p class="content">
        Memory hierarchy refers to the structure of different memory types in a computer, designed to provide fast access to data while maximizing storage efficiency. The main characteristics include speed, cost, size, and volatility.
      </p>
  
      <h2 class="sub-title">Introduction to Memory and Memory Units</h2>
      <p class="content">
        Memory is an essential component of a computer system, comprising various types of storage that hold data and instructions. Common units of memory include bytes, kilobytes (KB), megabytes (MB), gigabytes (GB), and terabytes (TB).
      </p>
  
      <h2 class="sub-title">Different Types of RAM (Random Access Memory)</h2>
      <ul class="characteristics-list">
        <li><strong>DRAM (Dynamic RAM):</strong> Needs to be refreshed thousands of times per second.</li>
        <li><strong>SRAM (Static RAM):</strong> Faster and more reliable but more expensive; used for cache memory.</li>
        <li><strong>SDRAM (Synchronous DRAM):</strong> Synchronized with the CPU clock for better performance.</li>
      </ul>
  
      <h2 class="sub-title">Buddy System: Memory Allocation Technique</h2>
      <p class="content">
        The buddy system divides memory into partitions to try and minimize fragmentation. It allocates memory in blocks that are powers of two, making it easier to manage.
      </p>
  
      <h2 class="sub-title">Memory Management | Partition Allocation Method</h2>
      <p class="content">
        Memory management strategies can be broadly classified into partition allocation methods, which include fixed and variable partitioning, allowing for efficient memory usage.
      </p>
  
      <h2 class="sub-title">Fixed (or Static) Partitioning in Operating System</h2>
      <p class="content">
        In fixed partitioning, memory is divided into fixed-size partitions. Each process is allocated a specific partition, which can lead to internal fragmentation.
      </p>
  
      <h2 class="sub-title">Variable (or Dynamic) Partitioning in Operating System</h2>
      <p class="content">
        Variable partitioning allows processes to be allocated only the amount of memory they need, reducing wastage but requiring more complex memory management.
      </p>
  
      <h2 class="sub-title">Non-Contiguous Allocation in Operating System</h2>
      <p class="content">
        Non-contiguous allocation allows processes to be stored in different areas of memory, which helps utilize memory more efficiently and reduces fragmentation.
      </p>
  
      <h2 class="sub-title">Logical vs Physical Address in Operating System</h2>
      <p class="content">
        A logical address is generated by the CPU, while a physical address is the actual location in memory. The operating system maps logical addresses to physical addresses.
      </p>
  
      <h2 class="sub-title">Paging</h2>
      <p class="content">
        Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory, thus avoiding external fragmentation.
      </p>
  
      <h2 class="sub-title">Requirements of Memory Management System</h2>
      <ul class="characteristics-list">
        <li>Efficient memory allocation and deallocation.</li>
        <li>Minimizing fragmentation.</li>
        <li>Ensuring protection and sharing of memory.</li>
        <li>Managing virtual memory.</li>
      </ul>
  
      <h2 class="sub-title">Memory Management â€“ Mapping Virtual Address to Physical Addresses</h2>
      <p class="content">
        Memory management includes mapping virtual addresses generated by processes to physical addresses in RAM, allowing for efficient memory usage.
      </p>
  
      <h2 class="sub-title">Page Table Entries</h2>
      <p class="content">
        Page table entries (PTEs) are data structures used in paging to store the mapping between virtual addresses and physical addresses, including information about the frame number and status.
      </p>
  
      <h2 class="sub-title">Virtual Memory</h2>
      <p class="content">
        Virtual memory extends the available memory on a system by using disk space to simulate additional RAM, allowing larger processes to run than the physical memory would otherwise permit.
      </p>
  
      <h2 class="sub-title">Memory Interleaving</h2>
      <p class="content">
        Memory interleaving is a technique that improves access speed by distributing memory addresses across multiple memory modules, allowing simultaneous access to different modules.
      </p>
  
      <h2 class="sub-title">Virtual Memory Questions</h2>
      <p class="content">
        <strong>Q: What is the purpose of virtual memory?</strong> <br>
        A: To enable the execution of processes that may not fit into the physical memory available.
      </p>
  
      <h2 class="sub-title">Operating System Based Virtualization</h2>
      <p class="content">
        OS-level virtualization allows multiple instances of an OS to run on a single physical machine, providing isolation and resource management for applications.
      </p>
  
      <h2 class="sub-title">Inverted Page Table</h2>
      <p class="content">
        An inverted page table is a memory management structure that maintains a single table for all physical frames, improving efficiency for large address spaces.
      </p>
  
      <h2 class="sub-title">Swap Space</h2>
      <p class="content">
        Swap space is a portion of the hard disk used to extend the system's memory by temporarily holding inactive pages of memory.
      </p>
  
      <h2 class="sub-title">Page Fault Handling</h2>
      <p class="content">
        When a program accesses a page that is not in memory, a page fault occurs, requiring the OS to retrieve the page from disk, which involves various handling strategies to minimize performance impact.
      </p>
  
      <h2 class="sub-title">Segmentation</h2>
      <p class="content">
        Segmentation is a memory management technique that divides memory into segments based on logical divisions such as functions or objects.
      </p>
  
      <h2 class="sub-title">Memory Segmentation in 8086 Microprocessor</h2>
      <p class="content">
        The 8086 microprocessor uses segmentation to address memory, allowing programs to access more memory than the addressable range of the processor.
      </p>
  
      <h2 class="sub-title">Program for Next Fit Algorithm in Memory Management</h2>
      <pre><code>
  // Example of Next Fit Algorithm
  int nextFit(int blockSize[], int m, int processSize[], int n) {
      int allocation[n];
      for (int i = 0; i < n; i++) allocation[i] = -1;
  
      int j = 0;
      for (int i = 0; i < n; i++) {
          while (j < m) {
              if (blockSize[j] >= processSize[i]) {
                  allocation[i] = j;
                  blockSize[j] -= processSize[i];
                  j = (j + 1) % m;
                  break;
              }
              j = (j + 1) % m;
          }
      }
      return allocation;
  }
      </code></pre>
  
      <h2 class="sub-title">Overlays in Memory Management</h2>
      <p class="content">
        Overlays allow a program to execute that is larger than the available memory by loading only the necessary parts into memory when required.
      </p>
  
      <h2 class="sub-title">Page Replacement Algorithms</h2>
      <p class="content">
        Page replacement algorithms determine which memory pages to remove when new pages need to be loaded. Key algorithms include LRU, FIFO, and Optimal Page Replacement.
      </p>
  
      <h2 class="sub-title">Program for Page Replacement Algorithms | Set 1 (LRU)</h2>
      <pre><code>
  // Example of LRU Page Replacement Algorithm
  int pageFaults(int pages[], int n, int capacity) {
      int pageFaults = 0;
      int memory[capacity];
      int index[capacity];
      int count = 0;
  
      for (int i = 0; i < capacity; i++) {
          memory[i] = -1;
      }
  
      for (int i = 0; i < n; i++) {
          int j;
          for (j = 0; j < capacity; j++) {
              if (memory[j] == pages[i]) break;
          }
  
          if (j == capacity) {
              if (count < capacity) {
                  memory[count++] = pages[i];
              } else {
                  int lruIndex = -1, lruTime = -1;
                  for (j = 0; j < capacity; j++) {
                      if (index[j] < lruTime || lruTime == -1) {
                          lruTime = index[j];
                          lruIndex = j;
                      }
                  }
                  memory[lruIndex] = pages[i];
              }
              pageFaults++;
          }
          index[j] = i;
      }
      return pageFaults;
  }
      </code></pre>
  
      <h2 class="sub-title">Program for Optimal Page Replacement Algorithm</h2>
      <pre><code>
  // Example of Optimal Page Replacement Algorithm
  int optimalPageReplacement(int pages[], int n, int capacity) {
      int memory[capacity];
      bool isPresent[capacity];
      int pageFaults = 0;
  
      for (int i = 0; i < capacity; i++) {
          memory[i] = -1;
          isPresent[i] = false;
      }
  
      for (int i = 0; i < n; i++) {
          int j;
          for (j = 0; j < capacity; j++) {
              if (memory[j] == pages[i]) {
                  isPresent[j] = true;
                  break;
              }
          }
  
          if (j == capacity) {
              int farthest = -1, replaceIndex = -1;
              for (j = 0; j < capacity; j++) {
                  if (!isPresent[j]) {
                      replaceIndex = j;
                      break;
                  }
                  int index = findFarthestIndex(pages, n, memory[j], i);
                  if (index > farthest) {
                      farthest = index;
                      replaceIndex = j;
                  }
              }
              memory[replaceIndex] = pages[i];
              pageFaults++;
          }
      }
      return pageFaults;
  }
  
  int findFarthestIndex(int pages[], int n, int page, int currentIndex) {
      for (int i = currentIndex; i < n; i++) {
          if (pages[i] == page) {
              return i;
          }
      }
      return n;
  }
      </code></pre>
  
      <h2 class="sub-title">LFU (Least Frequently Used) Cache Implementation</h2>
      <p class="content">
        LFU cache replacement algorithm keeps track of how often a page is accessed and replaces the least frequently used pages.
      </p>
  
      <h2 class="sub-title">Second Chance (or Clock) Page Replacement Policy</h2>
      <p class="content">
        The Second Chance algorithm is an enhancement to FIFO that gives pages a second chance based on their reference bit before replacement.
      </p>
  
      <h2 class="sub-title">Techniques to Handle Thrashing</h2>
      <p class="content">
        Thrashing occurs when excessive paging reduces performance. Techniques to manage this include increasing the number of frames allocated to processes and optimizing memory access patterns.
      </p>
  
      <h2 class="sub-title">Allocating Kernel Memory (Buddy System and Slab System)</h2>
      <p class="content">
        The buddy system and slab system are strategies for managing kernel memory allocation, helping to minimize fragmentation and improve allocation speed.
      </p>
  
      <h2 class="sub-title">Program for Buddy Memory Allocation Scheme in Operating Systems | Set 1 (Allocation)</h2>
      <pre><code>
  // Example of Buddy Memory Allocation Scheme
  void* buddyAlloc(int size) {
      // Implementation of buddy allocation
  }
      </code></pre>
  
      <h2 class="sub-title">Program for Buddy Memory Allocation Scheme in Operating Systems | Set 2 (Deallocation)</h2>
      <pre><code>
  // Example of Buddy Memory Deallocation
  void buddyFree(void* ptr) {
      // Implementation of buddy deallocation
  }
      </code></pre>
  
      <h2 class="sub-title">Static and Dynamic Libraries | Set 1</h2>
      <p class="content">
        Static libraries are linked at compile time, while dynamic libraries are linked at runtime, allowing for more flexible memory usage.
      </p>
  
      <h2 class="sub-title">Working with Shared Libraries | Set 1</h2>
      <p class="content">
        Shared libraries allow multiple programs to use the same library in memory, reducing memory consumption and improving performance.
      </p>
  
      <h2 class="sub-title">Working with Shared Libraries | Set 2</h2>
      <p class="content">
        Examples of using shared libraries include loading libraries dynamically in C/C++ using dlopen() and dlsym().
      </p>
  
      <h2 class="sub-title">Named Pipe or FIFO with Example C Program</h2>
      <pre><code>
  // Example of Named Pipe in C
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;unistd.h&gt;
  
  int main() {
      // Create a named pipe (FIFO)
      mkfifo("myfifo", 0666);
      char str[80];
      // Write to FIFO
      write(fd, str, sizeof(str));
      // Read from FIFO
      read(fd, str, sizeof(str));
      printf("Received: %s\n", str);
      return 0;
  }
      </code></pre>
  
      <h2 class="sub-title">Tracing Memory Usage in Linux</h2>
      <p class="content">
        Tools like top, htop, and vmstat can be used to trace memory usage in Linux systems, providing insights into resource utilization.
      </p>
  
      <h2 class="sub-title">Diagrams</h2>
      <p>Below are some diagrams that illustrate the concepts discussed:</p>
      <div class="diagram-container">
        <img src="path/to/memory_hierarchy.png" alt="Memory Hierarchy Diagram" />
        <img src="path/to/paging_diagram.png" alt="Paging Diagram" />
        <img src="path/to/segmentation_diagram.png" alt="Segmentation Diagram" />
      </div>
   
      <h2 class="sub-title">AI-Powered Study Companion</h2>
  <div class="ai-notes-section">
    <button 
      @click="generateAINotes" 
      class="example-button ai-notes-button" 
      :disabled="isGenerating"
    >
      {{ isGenerating ? 'Generating AI Study Guide...' : 'Generate AI Study Guide' }}
    </button>
    
    <div v-if="aiNotesData" class="ai-notes-display">
  <div class="ai-notes-content">
    <div class="notes-section">
      <h3 class="section-title">ðŸ“˜ Comprehensive Study Notes</h3>
      <p class="notes-text">{{ aiNotesData.studyNotes }}</p>
    </div>


        <div class="notes-section">
          <h3 class="section-title">ðŸŽ¯ Key Concepts</h3>
          <ul class="key-concepts-list">
            <li v-for="(concept, index) in aiNotesData.keyConcepts" :key="index">
              {{ concept }}
            </li>
          </ul>
        </div>

        <div class="notes-section">
          <h3 class="section-title">ðŸ’¡ Interview Questions</h3>
          <div class="interview-questions">
            <div 
              v-for="(question, index) in aiNotesData.interviewQuestions" 
              :key="index" 
              class="interview-question"
            >
              <strong>Q{{ index + 1 }}:</strong> {{ question }}
            </div>
          </div>
        </div>

        <div class="notes-section">
          <h3 class="section-title">ðŸŽ¥ Recommended Tutorials</h3>
          <div class="tutorial-links">
            <a 
              v-for="(tutorial, index) in aiNotesData.tutorialLinks" 
              :key="index"
              :href="tutorial.url"
              target="_blank"
              class="tutorial-link"
            >
              <span class="tutorial-platform">{{ tutorial.platform }}</span>
              <span class="tutorial-description">{{ tutorial.description }}</span>
            </a>
          </div>
        </div>

        <div class="notes-actions">
          <button @click="copyNotes" class="example-button copy-button">
            ðŸ“‹ Copy Study Guide
          </button>
          <button @click="downloadNotesPDF" class="example-button download-button">
            ðŸ“¥ Download PDF
          </button>
        </div>
      </div>
    </div>
  </div>
</div>
</template>
  
  <script>

import axios from 'axios';
import jspdf from 'jspdf';

export default {
name: "scalability",
data() {
  return {
    exampleCode: "",
    aiNotesData: null,
    isGenerating: false,
    selectedTopic: "",
    selectedSubtopic: "",
    loading: false,
    error: null,
    
    // Hardcoded API key (Note: In production, use secure methods)
    groqApiKey: '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',
    
    // Topics and subtopics
    
    
    // Expanded topics state
    expandedTopics: {}
  };

},

  methods: {
  
  // Add this method to the methods section
generateAINotes() {
// Choose a default topic and subtopic
const topic = "Memory Management";
const subtopic = "Memory management";

// Call the existing generateNotes method
this.generateNotes(topic, subtopic);
},
  
  // Generates the AI notes with a comprehensive prompt
  generatePrompt(topic, subtopic) {
    return `
Generate comprehensive programming notes about ${topic} - ${subtopic}.\n\n
Include the following sections:\n\n
1. Introduction and Basic Concepts\n\n
2. Key Features and Characteristics\n\n
3. Implementation Details\n\n
4. Common Operations and Time Complexity\n\n
5. Real-world Applications\n\n
6. Best Practices and Tips\n\n
Make the content detailed enough for both beginners and advanced programmers.\n
`;
},

  
  // Toggle topic expansion
  toggleTopic(topic) {
    this.$set(this.expandedTopics, topic, !this.expandedTopics[topic]);
  },
  
  // Generates AI notes for a specific topic
  async generateNotes(topic, subtopic) {
    if (!this.groqApiKey) {
      this.error = 'Missing API key. Please provide a valid API key and try again.';
      return;
    }

    this.loading = true;
    this.error = null;
    this.selectedTopic = `${topic} - ${subtopic}`;
    this.aiNotesData = null;

    try {
      const response = await axios.post('https://api.groq.com/openai/v1/chat/completions', {
        model: "mixtral-8x7b-32768",
        messages: [
          {
            role: "user",
            content: this.generatePrompt(topic, subtopic)
          }
        ],
        temperature: 0.7,
        max_tokens: 2000
      }, {
        headers: {
          'Authorization': `Bearer ${this.groqApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.data.choices || response.data.choices.length === 0) {
        throw new Error('No response generated. Please try again.');
      }

      const aiResponse = response.data.choices[0].message.content;
      
      // Parse and structure the AI response
      this.aiNotesData = {
        studyNotes: aiResponse,
        keyConcepts: this.extractKeyConcepts(aiResponse),
        interviewQuestions: this.extractInterviewQuestions(aiResponse),
        tutorialLinks: this.generateTutorialLinks(topic, subtopic)
      };
    } catch (error) {
      console.error('Error generating AI notes:', error);
      this.error = error.message || 'Failed to generate notes. Please try again.';
    } finally {
      this.loading = false;
    }
  },
  
  // Helper method to extract key concepts
  extractKeyConcepts(text) {
    const conceptsMatch = text.match(/Key Features and Characteristics:(.*?)(\n\n|$)/s);
    if (conceptsMatch) {
      return conceptsMatch[1].trim().split('\n')
        .filter(concept => concept.trim() !== '')
        .slice(0, 5);
    }
    return [
      "Definition and Basic Concepts",
      "Core Characteristics",
      "Key Implementation Details",
      "Important Properties",
      "Advanced Techniques"
    ];
  },
  
  // Helper method to extract interview questions
  extractInterviewQuestions(text) {
    const questionsMatch = text.match(/Common Interview Questions:(.*?)(\n\n|$)/s);
    if (questionsMatch) {
      return questionsMatch[1].trim().split('\n')
        .filter(q => q.trim() !== '')
        .slice(0, 3);
    }
    return [
      "What are the core principles of this topic?",
      "Explain the most important aspects and use cases.",
      "Discuss advanced implementation techniques."
    ];
  },
  
  // Generate tutorial links based on topic
  generateTutorialLinks(topic, subtopic) {
    return [
      {
        platform: 'YouTube',
        description: `${topic} - ${subtopic} Tutorial`,
        url: `https://www.youtube.com/results?search_query=${encodeURIComponent(topic + ' ' + subtopic)}`
      },
      {
        platform: 'Coursera',
        description: `Learn ${topic} in Depth`,
        url: `https://www.coursera.org/courses?query=${encodeURIComponent(topic)}`
      }
    ];
  },

  // Copy notes to clipboard
  copyNotes() {
    if (this.aiNotesData) {
      const notesText = `
Study Guide: ${this.selectedTopic}

ðŸ“˜ Study Notes:
${this.aiNotesData.studyNotes}

ðŸŽ¯ Key Concepts:
${this.aiNotesData.keyConcepts.map((c, i) => `${i + 1}. ${c}`).join('\n')}

ðŸ’¡ Interview Questions:
${this.aiNotesData.interviewQuestions.map((q, i) => `Q${i + 1}: ${q}`).join('\n')}

ðŸŽ¥ Recommended Tutorials:
${this.aiNotesData.tutorialLinks.map(t => `${t.platform}: ${t.description} - ${t.url}`).join('\n')}
      `;

      navigator.clipboard.writeText(notesText).then(() => {
        alert('Study guide copied to clipboard!');
      }).catch(err => {
        console.error('Failed to copy notes:', err);
        alert('Failed to copy notes. Please try again.');
      });
    }
  },

  // Download notes as PDF
  downloadNotesPDF() {
    if (this.aiNotesData) {
      const doc = new jspdf();
      
      doc.setFontSize(16);
      doc.text(`Study Guide: ${this.selectedTopic}`, 20, 20);
      
      doc.setFontSize(12);
      let yPos = 30;

      const addSection = (title, content) => {
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 255);
        doc.text(title, 20, yPos);
        
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        const splitContent = doc.splitTextToSize(content, 170);
        doc.text(splitContent, 20, yPos + 10);
        
        yPos += 20 + (splitContent.length * 10);
      };

      addSection('Study Notes', this.aiNotesData.studyNotes);
      
      addSection('Key Concepts', 
        this.aiNotesData.keyConcepts.map((c, i) => `${i + 1}. ${c}`).join('\n')
      );
      
      addSection('Interview Questions', 
        this.aiNotesData.interviewQuestions.map((q, i) => `Q${i + 1}: ${q}`).join('\n')
      );
      
      addSection('Recommended Tutorials', 
        this.aiNotesData.tutorialLinks.map(t => `${t.platform}: ${t.description} - ${t.url}`).join('\n')
      );

      doc.save(`${this.selectedTopic.replace(/\s+/g, '_')}_Study_Guide.pdf`);
    }
  }
}
};
</script>
<style scoped>
.matrix-container {
padding: 20px;
background: #000000;
border-radius: 10px;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
font-family: 'Arial', sans-serif;
color: #e4e4e4;
}

.main-title {
font-size: 2em;
color: #007bff;
text-align: center;
}

.sub-title {
font-size: 1.5em;
color: #0056b3;
margin-top: 20px;
}

.type-title {
font-size: 1.2em;
color: #ebe64d;
margin-top: 10px;
}

.characteristics-list {
list-style-type: disc;
padding-left: 40px;
}

.notes-text {
  white-space: pre-wrap; /* Preserves whitespace and newlines */
}


.matrix-diagram {
display: block;
margin: 20px auto;
max-width: 100%;
border: 1px solid #ddd;
border-radius: 5px;
}

.example-button {
padding: 10px 20px;
margin: 10px;
border: none;
border-radius: 5px;
background: #007bff;
color: #fff;
cursor: pointer;
font-size: 1em;
transition: background 0.3s;
}

.example-button:hover {
background: #000000;
}

.ai-notes-display {
margin-top: 20px;
background: #313131;
padding: 20px;
border-radius: 10px;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

.section-title {
font-size: 1.3em;
color: #007bff;
}

.key-concepts-list {
list-style-type: decimal;
padding-left: 40px;
}

.interview-questions {
margin: 10px 0;
}

.tutorial-link {
display: block;
margin: 5px 0;
color: #fbff00;
text-decoration: none;
}

.tutorial-link:hover {
text-decoration: underline;
}

.copy-button, .download-button {
margin-right: 10px;
background: #28a745;
}

.copy-button:hover, .download-button:hover {
background: #218838;
}
</style>